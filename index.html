<!DOCTYPE html>
<!-- 
  index.html - Main interface for the Image-to-Pixel Art Converter
  
  PURPOSE:
  This is the primary user interface for converting images to pixel art.
  It's designed for generating training data for ML models that need to
  understand pixel art transformations.
  
  ARCHITECTURE:
  - Uses vanilla JavaScript for maximum compatibility
  - Canvas-based rendering for real-time pixelation preview
  - Integrates with image-to-pixel.js for core processing algorithms
  - Supports multiple dithering methods and color palettes
  
  CONNECTIONS:
  - Loads image-to-pixel.js for pixelation algorithms
  - Loads src/picker.js for color palette management
  - Loads src/logo.js for branding elements
  - Styles from css/main.css, css/logo.css, css/picker.css
  
  TRAINING DATA GENERATION:
  - Supports batch processing via file upload
  - Exports in PNG format suitable for ML training
  - Preserves metadata about transformation parameters
-->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>ðŸŽ¨ Image-to-Pixel - Training Data Generator</title>
  <!-- Include Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Google Fonts for Modern Typography -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="css/logo.css">
  <link rel="stylesheet" type="text/css" href="css/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css" />
  <link rel="stylesheet" type="text/css" href="css/picker.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: var(--color-hover) var(--color-primary)
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px
    }

    ::-webkit-scrollbar-track {
      background: var(--color-primary)
    }

    ::-webkit-scrollbar-thumb {
      background-color: var(--color-hover);
      border-radius: 4px;
      border: 2px solid var(--color-primary)
    }

    .setting-group {
      position: relative;
    }

    .toggle-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 30px !important;
      height: 17px !important;
      background-color: var(--color-background) !important;
      border: none;
      border-radius: 10px;
      outline: none;
      cursor: pointer;
      transition: background-color 0.3s;
      padding: 9px 16px !important;
    }

    .toggle-btn.active {
      background-color: var(--color-accent) !important;
    }

    .toggle-thumb {
      position: absolute;
      top: 3px;
      left: 2px;
      width: 12px;
      height: 12px;
      background-color: var(--color-text);
      border-radius: 50%;
      transition: 0.3s;
      pointer-events: none;
      margin: 0 !important;
      padding: 0px !important;
    }

    .toggle-btn.active .toggle-thumb {
      left: 16px;
      background-color: white;
    }

    #paletteSelector {
      display: none;
    }
  </style>
</head>

<body>
  <header>
    <div id="logo-container" aria-label="Image-to-Pixel Logo">
    </div>
    <div class="download-buttons">
      <button id="downloadFull" title="Download Full Resolution">
                <i class="fas fa-download"></i>
            </button>
      <button id="downloadPixel" title="Download Pixelated Image">
                <i class="fas fa-file-image"></i>
            </button>
    </div>
  </header>
  <div class="container">
    <div class="tool-panel">
      <button id="pixelateButton">
                <i class="fa-solid fa-wand-magic-sparkles"></i> Pixelate
            </button>
      <button title="auto refresh" id="autoPixelateToggle" class="toggle-btn" aria-pressed="false">
                <span class="toggle-thumb"></span>
            </button>
      <div class="settings">
        <div class="setting-group">
          <label for="pixel-data">
                        <i class="fa-solid fa-chevron-down"></i>
                        Pixel Width</label>
          <div id="pixel-data" class="input-group">
            <select id="pixelWidthSelector">
                            <option value="16">16</option>
                            <option value="32">32</option>
                            <option value="64">64</option>
                            <option value="128" selected>128</option>
                            <option value="256">256</option>
                        </select>
            <div class="span-group">
              <span>Custom:</span>
              <input type="text" id="pixelWidthInput" value="128">
              <button id="autoDetectButton" title="Auto Detect Image Width">Auto Detect</button>
            </div>
          </div>
        </div>
        <div class="setting-group">
          <label for="dither-data">
                        <i class="fa-solid fa-chevron-down"></i>
                        Dither Type</label>
          <div id="dither-data" class="input-group">
            <select id="dithering">
                            <option value="none">None</option>
                            <option value="atkinson">Atkinson</option>
                            <option value="Floyd-Steinberg">Floyd-Steinberg</option>
                            <option value="2x2 Bayer">2x2 Bayer</option>
                            <option value="4x4 Bayer" selected>4x4 Bayer</option>
                            <option value="ordered">Ordered 8x8</option>
                            <option value="Clustered 4x4">Clustered 4x4</option>
                        </select>
            <div class="slider-container">
              <span>Strength</span>
              <input type="range" id="ditheringStrength" min="0" max="100" value="10">
            </div>
          </div>
        </div>
        <div class="setting-group">
          <label for="main-container">
                        <i class="fa-solid fa-chevron-down"></i>
                        Palette</label>
          <button id="palette-toggle" class="toggle-btn active" aria-pressed="true">
                        <span class="toggle-thumb"></span>
                    </button>
          <div id="main-container" class="main-container">
            <div class="palette-switcher">
              <div class="palette-list-wrapper">
                <h4>Default</h4>
                <select id="default-palette-selector"></select>
              </div>
              <div class="palette-list-wrapper">
                <h4>Custom</h4>
                <select id="custom-palette-selector">
                                    <option value="none">None</option>
                                </select>
              </div>
            </div>
            <input type="text" id="palette-name-input" placeholder="Enter palette name" />
            <div class="color-list">
              <div id="selected-colors"></div>
            </div>
            <div class="controls">
              <button id="add-color-button">Add Color</button>
              <button id="save-palette-button" class="save-button">Save</button>
              <button id="delete-palette-button" class="delete-button">Delete</button>
            </div>
            <button id="upload-palette-button">Upload Palette</button>
            <button id="download-palette-button">Download Palette</button>
            <input type="file" id="palette-file-input" style="display:none" accept=".json">
            <div id="hidden-picker"></div>
          </div>
        </div>
        <div title="the slug is the last part of the lospec URL-EX: https://lospec.com/palette-list/rgbg-36"
          class="setting-group">
          <button id="lospec-toggle" class="toggle-btn" aria-pressed="false">
                        <span class="toggle-thumb"></span>
                    </button>
          </button>
          <label for="palette-input">
                        <i class="fa-solid fa-chevron-down"></i>
                        Lospec Palette</label>
          <div id="palette-input" class="input-group">

            <select id="paletteSelector">
                            <option value="rgbg-36" selected>rgbg-36</option>
                        </select>
            <div class="span-group">
              <span>Slug:</span>
              <input type="text" id="paletteInput" value="rgbg-36">
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="main-content">
      <div id="dropzone">
        <p>Drop an image or click to upload</p>
      </div>
       <div id="target-dropzone" class="dropzone-extra">
        <p>Drop a target style image here</p>
        <span id="palette-info"></span>
      </div>
      <div class="canvas-wrapper">
        <canvas id="canvas"></canvas>
      </div>
      <input type="file" id="fileInput" style="display:none" accept="image/*">
      <input type="file" id="target-file-input" style="display:none" accept="image/*">
    </div>
  </div>
  <script src="src/logo.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>
  <script src="src/picker.js"></script>
  <script src="image-to-pixel.js"></script>
  <script>
    /**
     * UI Interaction Controller
     * 
     * This script manages all user interface interactions including:
     * - Collapsible settings panels (chevron toggles)
     * - Image upload and display
     * - Pixelation parameter controls
     * - Export functionality for training data
     * 
     * STATE MANAGEMENT:
     * - originalImageObject: Stores the uploaded image for processing
     * - pixelatedCanvas: Stores the processed result for export
     * - autoPixelateEnabled: Controls real-time preview updates
     * - activeToggle: Tracks which palette source is active
     * 
     * CRITICAL FOR TRAINING DATA:
     * The consistency of parameters across batch processing is essential
     * for generating coherent training datasets.
     */
    document.querySelectorAll('label[for]').forEach(label => {
            label.onclick = () => {
                const targetId = label.getAttribute('for');
                const targetElement = document.getElementById(targetId);
                const chevron = label.querySelector('.fa-chevron-down, .fa-chevron-right');

                if (targetElement) {
                    if (!targetElement.style.maxHeight) {
                        targetElement.style.maxHeight = targetElement.scrollHeight + 'px';
                    }

                    const isHidden = targetElement.style.maxHeight === '0px';
                    targetElement.style.maxHeight = isHidden ? targetElement.scrollHeight + 'px' : '0px';
                    targetElement.style.overflow = 'hidden';  // Ensure content doesn't overflow

                    if (chevron) {
                        chevron.classList.toggle('fa-chevron-right', !isHidden);
                        chevron.classList.toggle('fa-chevron-down', isHidden);
                    }
                }
            };
        });

        /**
         * Auto-detect image dimensions for optimal pixelation.
         * 
         * This feature is crucial for training data generation as it ensures
         * the pixel grid aligns naturally with the source image dimensions,
         * preventing artifacts that could confuse ML models.
         */
        const autoDetectButton = document.getElementById('autoDetectButton');
        autoDetectButton.addEventListener('click', () => {
            if (originalImageObject) {
                const imageWidth = originalImageObject.width;
                pixelWidthInput.value = imageWidth;
                pixelWidthSelector.value = imageWidth;
                console.log(`Detected image width: ${imageWidth}px`);

                if (autoPixelateEnabled) applyPixelation();
            } else {
                console.warn("No image detected. Please upload an image first.");
            }
        });



        let activeToggle = document.getElementById('palette-toggle');
        const autoPixelateToggle = document.getElementById('autoPixelateToggle');

        const toggles = document.querySelectorAll('.toggle-btn');

        autoPixelateToggle.classList.toggle('active', autoPixelateEnabled);
        autoPixelateToggle.setAttribute('aria-pressed', autoPixelateEnabled.toString());

        toggles.forEach(toggle => {
            toggle.addEventListener('click', function () {
                if (this.id === 'autoPixelateToggle') {
                    autoPixelateEnabled = !autoPixelateEnabled;
                    this.classList.toggle('active', autoPixelateEnabled);
                    this.setAttribute('aria-pressed', autoPixelateEnabled.toString());
                    return;
                }

                if (activeToggle !== this) {
                    toggles.forEach(btn => {
                        if (btn.id !== 'autoPixelateToggle') {
                            btn.classList.remove('active');
                            btn.setAttribute('aria-pressed', 'false');
                        }
                    });

                    this.classList.add('active');
                    this.setAttribute('aria-pressed', 'true');
                    activeToggle = this;
                } else {
                    this.classList.remove('active');
                    this.setAttribute('aria-pressed', 'false');
                    activeToggle = null;
                }
            });
        });

        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const targetDropzone = document.getElementById('target-dropzone');
        const targetFileInput = document.getElementById('target-file-input');
        const paletteInfo = document.getElementById('palette-info');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pixelateButton = document.getElementById('pixelateButton');
        const downloadFullButton = document.getElementById('downloadFull');
        const downloadPixelButton = document.getElementById('downloadPixel');
        const pixelWidthInput = document.getElementById('pixelWidthInput');
        const paletteNameInput = document.getElementById('paletteInput');
        const ditheringSelect = document.getElementById('dithering');
        const ditheringStrengthInput = document.getElementById('ditheringStrength');

        pixelWidthSelector.addEventListener('change', () => {
            pixelWidthInput.value = pixelWidthSelector.value;
        });
        pixelWidthInput.addEventListener('input', () => {
            pixelWidthSelector.value = pixelWidthInput.value;
        });

        const paletteSelector = document.getElementById('paletteSelector');
        paletteSelector.addEventListener('change', () => {
            paletteNameInput.value = paletteSelector.value;
        });
        paletteNameInput.addEventListener('input', () => {
            paletteSelector.value = paletteNameInput.value;
        });

        let originalImageObject = null;
        let pixelatedCanvas = null;
        let customPaletteFromImage = null;

        dropzone.addEventListener('click', () => fileInput.click());
        targetDropzone.addEventListener('click', () => targetFileInput.click());

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) displayImage(file);
        });

        dropzone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropzone.style.borderColor = '#0084ff';
        });
        dropzone.addEventListener('dragleave', () => {
            dropzone.style.borderColor = '#cccccc';
        });
        dropzone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropzone.style.borderColor = '#cccccc';
            const files = event.dataTransfer.files;
            if (files.length) displayImage(files[0]);
        });

        targetFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) handleTargetImage(file);
        });

        targetDropzone.addEventListener('dragover', (event) => {
            event.preventDefault();
            targetDropzone.style.borderColor = '#0084ff';
        });

        targetDropzone.addEventListener('dragleave', () => {
            targetDropzone.style.borderColor = '#cccccc';
        });

        targetDropzone.addEventListener('drop', (event) => {
            event.preventDefault();
            targetDropzone.style.borderColor = '#cccccc';
            const files = event.dataTransfer.files;
            if (files.length) handleTargetImage(files[0]);
        });

        function handleTargetImage(file) {
            extractPaletteFromImage(file).then(palette => {
                customPaletteFromImage = palette;
                paletteInfo.textContent = `${palette.length} colors`;

                // Add or update the custom palette option in the dropdown
                const customSelector = document.getElementById('custom-palette-selector');
                let option = customSelector.querySelector('option[value="from-image"]');
                if (!option) {
                    option = document.createElement('option');
                    option.value = 'from-image';
                    option.textContent = 'From Target Image';
                    customSelector.appendChild(option);
                }
                customSelector.value = 'from-image';

                // Manually set the activePalette and trigger a re-pixelation
                activePalette = customPaletteFromImage;
                // Deactivate other toggles
                toggles.forEach(btn => {
                    if (btn.id !== 'autoPixelateToggle' && btn.id !== 'palette-toggle') {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-pressed', 'false');
                    }
                });
                const paletteToggle = document.getElementById('palette-toggle');
                if (!paletteToggle.classList.contains('active')) {
                    paletteToggle.classList.add('active');
                    paletteToggle.setAttribute('aria-pressed', 'true');
                }
                activeToggle = paletteToggle;

                // Update the color list UI
                activePalette = customPaletteFromImage.map(rgb => {
                    return `#${rgb.map(c => c.toString(16).padStart(2, '0')).join('')}`;
                });
                updateColorList();


                if (autoPixelateEnabled) applyPixelation();
            }).catch(error => {
                console.error("Error extracting palette:", error);
                paletteInfo.textContent = "Error";
            });
        }

        async function extractPaletteFromImage(file) {
            const image = await loadOriginalImage(file);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = image.width;
            tempCanvas.height = image.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(image, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, image.width, image.height).data;
            const colorSet = new Set();

            for (let i = 0; i < imageData.length; i += 4) {
                // Ignore transparent pixels
                if (imageData[i + 3] === 0) continue;
                colorSet.add(`${imageData[i]},${imageData[i+1]},${imageData[i+2]}`);
            }

            return Array.from(colorSet).map(rgbString => {
                return rgbString.split(',').map(num => parseInt(num, 10));
            });
        }


        /**
         * Display uploaded image in the canvas with proper scaling.
         * 
         * This function is called when a user uploads an image via drag-drop
         * or file picker. It's the entry point for the conversion pipeline.
         * 
         * PROCESS FLOW:
         * 1. Read file as data URL
         * 2. Create Image object for processing
         * 3. Calculate display dimensions maintaining aspect ratio
         * 4. Render to canvas for preview
         * 
         * @param {File} file - The image file uploaded by the user
         */
        function displayImage(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const image = new Image();
                image.onload = function () {
                    originalImageObject = image;

                    const container = document.querySelector('.canvas-wrapper');
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    const imageAspectRatio = image.width / image.height;

                    let canvasWidth, canvasHeight;

                    if (containerWidth / containerHeight > imageAspectRatio) {
                        canvasHeight = containerHeight;
                        canvasWidth = canvasHeight * imageAspectRatio;
                    } else {
                        canvasWidth = containerWidth;
                        canvasHeight = canvasWidth / imageAspectRatio;
                    }

                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    ctx.imageSmoothingEnabled = false;
                    canvas.style.imageRendering = 'pixelated';
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.imageSmoothingEnabled = true;
                    ctx.drawImage(
                        image,
                        0, 0, image.width, image.height,
                        0, 0, canvas.width, canvas.height
                    );
                    canvas.style.imageRendering = 'auto';
                    canvas.style.display = 'block';
                    dropzone.classList.add('active');
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * Apply pixelation transformation to the loaded image.
         * 
         * This is the core function that orchestrates the pixelation process.
         * It gathers all user-configured parameters and calls the pixelate()
         * function from image-to-pixel.js.
         * 
         * PARAMETERS COLLECTED:
         * - pixelsWide: Target pixel width for the output
         * - paletteName: Lospec palette slug if using external palette
         * - ditheringMethod: Algorithm for color approximation
         * - ditheringStrength: Intensity of dithering effect (0-100)
         * - activePalette: Currently selected color palette
         * 
         * CRITICAL FOR TRAINING DATA:
         * Consistency in these parameters across batches is essential
         * for generating coherent training datasets.
         * 
         * @returns {Promise<void>} Renders result to canvas when complete
         */
        async function applyPixelation() {
            if (!originalImageObject) return;
            const pixelsWide = parseInt(pixelWidthInput.value) || 10;
            const paletteName = paletteNameInput.value.trim();
            const ditheringMethod = ditheringSelect.value;
            const ditheringStrength = parseInt(ditheringStrengthInput.value); // Strength is 0-100

            let paletteToUse;
            if (activeToggle && activeToggle.id === 'lospec-toggle') {
                paletteToUse = paletteName;
            } else {
                paletteToUse = activePalette;
            }

            const options = {
                image: originalImageObject,
                width: pixelsWide,
                dither: ditheringMethod,
                strength: ditheringStrength,
                palette: paletteToUse,
                resolution: 'pixel',
            };

            try {
                const resultCanvas = await pixelate(options);

                pixelatedCanvas = resultCanvas;

                const container = document.querySelector('.canvas-wrapper');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                const imageAspectRatio = resultCanvas.width / resultCanvas.height;

                let canvasWidth, canvasHeight;

                if (containerWidth / containerHeight > imageAspectRatio) {
                    canvasHeight = containerHeight;
                    canvasWidth = canvasHeight * imageAspectRatio;
                } else {
                    canvasWidth = containerWidth;
                    canvasHeight = canvasWidth / imageAspectRatio;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.imageSmoothingEnabled = false; // Disable smoothing for pixelated image
                ctx.drawImage(resultCanvas, 0, 0, canvas.width, canvas.height);
                resultCanvas.style.imageRendering = 'pixelated'; // Crisp pixel rendering
                canvas.style.display = 'block';
            } catch (error) {
                console.error(error);
            }
        }

        pixelateButton.addEventListener('click', applyPixelation);
        pixelWidthInput.addEventListener('input', () => {
            if (autoPixelateEnabled) applyPixelation();
        });
        ditheringSelect.addEventListener('change', () => {
            if (autoPixelateEnabled) applyPixelation();
        });
        ditheringStrengthInput.addEventListener('input', () => {
            if (autoPixelateEnabled) applyPixelation();
        });
        paletteNameInput.addEventListener('input', () => {
            if (autoPixelateEnabled) applyPixelation();
        });
        paletteSelector.addEventListener('change', () => {
            if (autoPixelateEnabled) applyPixelation();
        });

        pixelWidthSelector.addEventListener('change', () => {
            if (autoPixelateEnabled) applyPixelation();
        });
        /**
         * Export pixelated image at pixel resolution.
         * 
         * This exports the image at its actual pixelated size, which is
         * ideal for training data as it preserves the exact pixel structure
         * without any upscaling artifacts.
         * 
         * OUTPUT FORMAT:
         * - PNG format for lossless compression
         * - Actual pixel dimensions (e.g., 32x32, 64x64)
         * - No interpolation or smoothing applied
         */
        downloadPixelButton.addEventListener('click', () => {
            if (!pixelatedCanvas) return;
            const link = document.createElement('a');
            link.href = pixelatedCanvas.toDataURL('image/png');
            link.download = 'pixelated-image.png';
            link.click();
        });

        /**
         * Export pixelated image at original resolution.
         * 
         * This creates a pixelated version at the original image dimensions,
         * useful for training models that need to understand how pixel art
         * appears when scaled up to match source image sizes.
         * 
         * PROCESS:
         * 1. Apply pixelation at low resolution
         * 2. Scale up to original dimensions using nearest-neighbor
         * 3. Export as PNG for training data
         * 
         * USE CASE:
         * Training models to recognize pixel art patterns at various scales
         * or to generate high-resolution outputs from pixel art inputs.
         */
        downloadFullButton.addEventListener('click', async () => {
            if (!originalImageObject) return;

            const pixelsWide = parseInt(pixelWidthInput.value) || 10;
            const paletteName = paletteNameInput.value.trim();
            const ditheringMethod = ditheringSelect.value;
            const ditheringStrength = parseInt(ditheringStrengthInput.value);

            let paletteToUse;
            if (activeToggle && activeToggle.id === 'lospec-toggle') {
                paletteToUse = paletteName;
            } else {
                paletteToUse = activePalette;
            }
            const options = {
                image: originalImageObject,
                width: pixelsWide,
                dither: ditheringMethod,
                strength: ditheringStrength,
                palette: paletteToUse,
                resolution: 'original',
            };

            try {
                const fullCanvas = await pixelate(options);
                const link = document.createElement('a');
                link.href = fullCanvas.toDataURL('image/png');
                link.download = 'full-resolution-pixelated.png';
                link.click();
            } catch (error) {
                console.error(error);
                alert('An error occurred during downloading the full-resolution image.');
            }
        });
  </script>
</body>

</html>